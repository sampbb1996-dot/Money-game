<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Threshold</title>

<style>
* {
  -webkit-user-select: none !important;
  user-select: none !important;
  -webkit-touch-callout: none !important;
  -webkit-tap-highlight-color: transparent !important;
  outline: none !important;
}

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #050b14;
  touch-action: none;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

/* === GAME STATE === */
let state = "waiting"; // waiting | active | fail
let startTime = 0;
let windowStart = 0;
let windowEnd = 0;

let difficulty = 600; // ms window (shrinks)
let lastResult = null;

/* === INPUT === */
addEventListener("pointerdown", e => {
  e.preventDefault();

  const now = performance.now();

  if (state === "waiting") return;

  if (state === "active") {
    if (now >= windowStart && now <= windowEnd) {
      // SUCCESS
      difficulty *= 0.92;
      lastResult = "hit";
    } else {
      // FAIL
      difficulty = Math.min(difficulty * 1.15, 1200);
      lastResult = "miss";
    }
    state = "waiting";
  }
}, { passive:false });

/* === LOOP === */
function scheduleNext() {
  const delay = 800 + Math.random() * 1200;
  setTimeout(() => {
    startTime = performance.now();
    windowStart = startTime + 300;
    windowEnd = windowStart + difficulty;
    state = "active";
  }, delay);
}
scheduleNext();

/* === RENDER === */
function draw() {
  ctx.fillStyle = "#050b14";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const now = performance.now();

  // subtle noise field
  for (let i=0;i<60;i++){
    ctx.globalAlpha = 0.04;
    ctx.strokeStyle = "#cfd8e3";
    ctx.beginPath();
    const x = Math.random()*innerWidth;
    const y = Math.random()*innerHeight;
    ctx.moveTo(x,y);
    ctx.lineTo(x+Math.random()*6,y+Math.random()*6);
    ctx.stroke();
  }

  // active window indicator (barely visible)
  if (state === "active") {
    const t = (now - windowStart) / (windowEnd - windowStart);
    if (t>=0 && t<=1){
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(
        innerWidth*0.5 - 40,
        innerHeight*0.5 - 40,
        80,
        80
      );
    }
  }

  // feedback (non-verbal)
  if (lastResult) {
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = lastResult === "hit" ? "#00ff99" : "#ff3355";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    lastResult = null;
    scheduleNext();
  }

  requestAnimationFrame(draw);
}

draw();

/* === HARD BLOCK DEFAULTS === */
["touchstart","touchmove","contextmenu"].forEach(evt=>{
  addEventListener(evt,e=>e.preventDefault(),{passive:false});
});
</script>
</body>
</html>